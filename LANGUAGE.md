# design goals
There is a niche in the world of programming languages that isn't being filled right now. Statically typed functional programming languages like OCaml and Haskell are awesome, they use the type system to enable you to write largely bug free code. These languages have problems though, and Hoyle aims to solve several of them: iteration time, performance, and others.

## Slow iteration time
One of the biggest complaints about statically typed languages in general is iteration time, or how easy it is to make a small MVP of a program before writing the finished project. Even if a program hasn’t had all of the error paths completely fleshed out, it can still be useful to run the program and make sure that the happy path is working. Languages with unchecked exceptions make this easy, the user can just not catch any exceptions, then add try-catch blocks later when they are satisfied with the happy path. On the other hand, languages like Haskell and OCaml handle errors by passing the user a wrapped type that they have to check for errors before they can access the underlying value. This system undeniably has advantages: it allows you to guarantee that your code will almost never crash, and it encourages you to handle errors rather than just rethrowing them, but these benefits seemingly come at the cost of slow iteration time. It makes sense that to get the benefits of crash-free production code you would have to sacrifice quick and dirty development code, but Hoyle provides an alternative.

In Hoyle, `T ! E` is the type of an expression that could either be a `T`, the success case, or an `E`, the error case. `!` is subtly different from other sum types in a couple of ways. The first is that you don’t need to wrap either variant in a constructor, you don’t need to write `Ok(my_t)` or `Error(my_e)` like you would in OCaml, instead you write `my_t`, or `throw my_e`. The second is that in development mode, the compiler will automatically unwrap all unchecked errors for you. If you call a function that accepts a `Json` struct with a `Json ! Error`, the compiler will automatically insert some code that crashes if the `Json ! Error` is an `Error` and just issues a warning. On the other hand, in production mode, not checking for an `Error` is a compiler error.

## Performance
Both OCaml and Haskell make use of the linked list as their core data structure. In fact, both languages use the structure religiously. Linked lists are remarkable because of exactly one property: they enable easy structural sharing, which is critical because all values are immutable, so copies are frequently made. Similarly, balanced binary tree data structures are often used for key-value maps because of their structural sharing properties. Although these data structures have very good big-O classes (O(1) and O(log n) respectively), they have sub-par performance because of their poor allocation patterns and excessive comparison operations for searching. Alternatives using HAMTs like Rust’s im::HashMap have proved to be high-performance options. Hoyle includes such data structures as the built-in default.

## Polymorphic Variants
A common issue with algebraic data types is that dealing with sum types can be painful. If a function takes a `T ! E`, handles one possible case of `E`, then returns the value. To accurately write that function’s type you would have to define a new sum type that is exactly like `E` but without the case that was handled. This is only one example of sum types being inconvenient.

Hoyle has a number of features that make dealing with sum types less painful, but they are all centered around the idea of variant polymorphism. Variants are structurally typed. The expression `Just 5` has the type `Just int`, which is a subtype of the maybe type `Just a | Nothing`. The | operator is similar to | in TypeScript, but instead of allowing you to construct the union of any two types, | in Hoyle only allows you to union variant types, making it easy to extend a variant with one extra case. As part of Hoyle’s structural variant typing, Hoyle allows different sum types to reuse the same variant name, in the same namespace, without conflict.
